<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgpu - reflection</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

	<div id="info">

		Press <strong>S</strong> to save camera position
	</div>

	<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

	<script type="module">

		import * as THREE from 'three/webgpu';

		import { abs, blendOverlay, color, float, Fn, instancedBufferAttribute, materialColor, max, normalWorldGeometry, pass, positionGeometry, positionLocal, pow2, reflector, screenUV, sin, sub, texture, time, uniform, uv, vec2, vec3 } from 'three/tsl';
		import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		import Stats from 'three/addons/libs/stats.module.js';
		import TWEEN from 'three/addons/libs/tween.module.js';

		/*
		=== TREE CUSTOMIZATION GUIDE ===
		
		The tree is now generated using a seeded random system for consistent results.
		
		To customize the tree:
		1. Change TREE_SEED to get different but consistent tree shapes
		2. Modify TREE_PARAMS to change the tree structure:
			 - maxSteps: Number of branching levels (higher = more complex)
			 - lengthMult: How much shorter each branch gets (0.8-0.95)
			 - branchCount: Number of branches per node (3-8)
			 - initialLength: Starting branch length
			 - initialAngle: Starting angle (0=right, PI/2=up, PI=left)
		
		Example tree styles:
		- Bushy tree: { maxSteps: 5, lengthMult: 0.85, branchCount: 8 }
		- Tall tree: { maxSteps: 6, lengthMult: 0.92, branchCount: 4 }
		- Wide tree: { maxSteps: 4, lengthMult: 0.88, branchCount: 6, initialAngle: 0 }
		*/

		let camera, scene, renderer;
		let postProcessing;
		let controls;
		let stats;

		// Mouse interaction variables
		let mouse = new THREE.Vector2();
		let isHoveringScene = false;
		let originalCameraPosition = new THREE.Vector3();
		let hoverCameraOffset = new THREE.Vector3();

		// below uniforms will be animated via TWEEN.js

		const uniformEffector1 = uniform(- 0.2);
		const uniformEffector2 = uniform(- 0.2);
		const uniformEffector3 = uniform(- 0.2);

		init();

		async function init() {

			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.25, 30);
			camera.position.set(0.091, 5.899, 8.437);

			scene = new THREE.Scene();
			// Create dark atmospheric background
			scene.background = new THREE.Color(0x000000);
			camera.lookAt(0, 1, 0);

			// Very dim ambient light to prevent complete blackness
			const ambientLight = new THREE.AmbientLight(0x202020, 0.1);
			scene.add(ambientLight);

			// Main tree lighting - focused on the tree area
			const mainTreeLight = new THREE.SpotLight(0xffffff, 15, 20, Math.PI / 6, 0.1, 3);
			mainTreeLight.position.set(0, 8, 4);
			mainTreeLight.target.position.set(0, 2, 0);
			mainTreeLight.castShadow = true;
			mainTreeLight.shadow.mapSize.width = 2048;
			mainTreeLight.shadow.mapSize.height = 2048;
			mainTreeLight.shadow.camera.near = 0.5;
			mainTreeLight.shadow.camera.far = 20;
			scene.add(mainTreeLight);
			scene.add(mainTreeLight.target);

			// Secondary tree lighting from different angles
			const treeLight1 = new THREE.PointLight(0xffe6cc, 12, 8);
			treeLight1.position.set(3, 3, 2);
			scene.add(treeLight1);

			const treeLight2 = new THREE.PointLight(0xe6f3ff, 10, 8);
			treeLight2.position.set(-3, 4, 1);
			scene.add(treeLight2);

			const treeLight3 = new THREE.PointLight(0xfff0e6, 8, 6);
			treeLight3.position.set(0, 6, -2);
			scene.add(treeLight3);

			// Accent lights for tree details
			const accentLight2 = new THREE.PointLight(0x87ceeb, 5, 5);
			accentLight2.position.set(-2, 2, 2);
			scene.add(accentLight2);

			// Subtle rim lighting
			const rimLight = new THREE.DirectionalLight(0x404040, 3);
			rimLight.position.set(5, 3, 5);
			scene.add(rimLight);

			// Add atmospheric lighting around the tree
			const treeAtmosphereLight = new THREE.PointLight(0x4a90e2, 8, 12); // Blue atmospheric light
			treeAtmosphereLight.position.set(0, 3, 0);
			scene.add(treeAtmosphereLight);

			// Add ground illumination light
			const groundLight = new THREE.SpotLight(0x2c5aa0, 6, 15, Math.PI / 3, 0.3, 2);
			groundLight.position.set(0, 4, 0);
			groundLight.target.position.set(0, 0, 0);
			groundLight.castShadow = true;
			scene.add(groundLight);
			scene.add(groundLight.target);

			// textures

			const textureLoader = new THREE.TextureLoader();

			const floorColor = await textureLoader.loadAsync('textures/floors/FloorsCheckerboard_S_Diffuse.jpg');
			floorColor.wrapS = THREE.RepeatWrapping;
			floorColor.wrapT = THREE.RepeatWrapping;
			floorColor.colorSpace = THREE.SRGBColorSpace;
			floorColor.repeat.set(15, 15);

			const floorNormal = await textureLoader.loadAsync('textures/floors/FloorsCheckerboard_S_Normal.jpg');
			floorNormal.wrapS = THREE.RepeatWrapping;
			floorNormal.wrapT = THREE.RepeatWrapping;
			floorNormal.repeat.set(15, 15);

			// tree

			const treeMesh = createTreeMesh();
			treeMesh.castShadow = true;
			treeMesh.receiveShadow = true;
			scene.add(treeMesh);

			// floor - Water/Metal reflective surface

			const floorUV = uv().mul(15);
			const floorNormalOffset = texture(floorNormal, floorUV).xy.mul(2).sub(1).mul(.02);

			// Create a high-quality reflection with better resolution
			const reflection = reflector({ resolution: 1.0 });
			reflection.target.rotateX(-Math.PI / 2);
			reflection.uvNode = reflection.uvNode.add(floorNormalOffset);
			scene.add(reflection.target);

			// Create a water/metal material with enhanced reflections and ambient ground lighting
			const floorMaterial = new THREE.MeshStandardNodeMaterial();

			// Base color - dark blue-gray for water, or metallic gray
			const baseColor = vec3(0.1, 0.15, 0.2); // Dark blue-gray water color
			floorMaterial.colorNode = baseColor;

			// Enhanced reflection with higher intensity
			floorMaterial.emissiveNode = reflection.mul(1.8); // Increased from 0.25 to 0.8

			// Add metallic properties
			floorMaterial.metalnessNode = float(0.9); // High metalness for water/metal look
			floorMaterial.roughnessNode = float(0.1); // Low roughness for smooth reflections

			// Subtle normal mapping for water ripples
			floorMaterial.normalMap = floorNormal;
			floorMaterial.normalScale.set(0.1, - 0.1); // Reduced for subtler effect

			// Simple reflection only - no ground lighting effects
			floorMaterial.emissiveNode = reflection.mul(1.8);

			const floor = new THREE.Mesh(new THREE.BoxGeometry(50, .001, 50), floorMaterial);
			floor.receiveShadow = true;
			scene.add(floor);

			// renderer

			renderer = new THREE.WebGPURenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setAnimationLoop(animate);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			document.body.appendChild(renderer.domElement);

			stats = new Stats();
			document.body.appendChild(stats.dom);

			// controls

			controls = new OrbitControls(camera, renderer.domElement);
			controls.minDistance = 1;
			controls.maxDistance = 10;
			controls.maxPolarAngle = Math.PI / 2;
			controls.enableDamping = true;
			// controls.autoRotate = true;
			controls.autoRotateSpeed = 1;
			controls.target.set(0.285, 2.644, -0.456);

			// Disable mouse controls
			controls.enablePan = false;
			controls.enableRotate = false;
			controls.enableZoom = false;

			controls.update();

			// post-processing

			const scenePass = pass(scene, camera);
			const scenePassColor = scenePass.getTextureNode();
			const scenePassDepth = scenePass.getLinearDepthNode().remapClamp(.3, .7);

			const scenePassColorBlurred = gaussianBlur(scenePassColor);
			scenePassColorBlurred.directionNode = scenePassDepth;

			const vignette = screenUV.distance(.5).mul(1.25).clamp().oneMinus().sub(0.2);

			postProcessing = new THREE.PostProcessing(renderer);
			postProcessing.outputNode = blendOverlay(scenePassColorBlurred, vignette);

			// tweens - alternating waves with 1-second fixed intervals
			// Pattern: Wave1 (0-2s) -> 1s gap -> Wave2 (3-5s) -> 1s gap -> Wave3 (6-8s) -> 1s gap -> repeat

			new TWEEN.Tween(uniformEffector1)
				.to({ value: 1.1 }, 3000)
				.delay(0)
				.repeat(Infinity)
				.easing(TWEEN.Easing.Sinusoidal.InOut)
				.start();

			new TWEEN.Tween(uniformEffector2)
				.to({ value: 1.2 }, 3000)
				.delay(3000) // 2000ms duration + 1000ms gap
				.repeat(Infinity)
				.easing(TWEEN.Easing.Sinusoidal.InOut)
				.start();

			new TWEEN.Tween(uniformEffector3)
				.to({ value: 1.3 }, 2000)
				.delay(6000) // 2000ms duration + 1000ms gap + 2000ms duration + 1000ms gap
				.repeat(Infinity)
				.easing(TWEEN.Easing.Sinusoidal.InOut)
				.start();
			// Store original camera position for hover effects
			originalCameraPosition.copy(camera.position);

			// Mouse interaction events
			window.addEventListener('mousemove', onMouseMove);
			window.addEventListener('mouseleave', onMouseLeave);

			window.addEventListener('resize', onWindowResize);

			// Add keyboard listener for saving camera position
			window.addEventListener('keydown', onKeyDown);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function onMouseMove(event) {
			// Calculate mouse position in normalized device coordinates (-1 to 1)
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

			// Set hovering state
			isHoveringScene = true;

			// Calculate camera movement based on mouse position
			// The further from center, the more the camera moves
			const sensitivity = 0.5; // Adjust this value to control movement sensitivity

			// X-axis movement (left/right)
			hoverCameraOffset.x = mouse.x * sensitivity;

			// Y-axis movement (up/down) - reduced sensitivity for more subtle vertical movement
			hoverCameraOffset.y = mouse.y * sensitivity * 0.5;

			// Z-axis movement (forward/backward) - subtle depth movement
			hoverCameraOffset.z = Math.abs(mouse.x) * sensitivity * 0.5;
		}

		function onMouseLeave() {
			// Reset hover state when mouse leaves the window
			isHoveringScene = false;
			hoverCameraOffset.set(0, 0, 0);
		}

		function onKeyDown(event) {
			// Press 'S' key to save camera position and lookAt
			if (event.key.toLowerCase() === 's') {
				saveCameraParameters();
			}
		}

		function saveCameraParameters() {
			// Get current camera position
			const position = camera.position;
			const target = controls.target;

			// Format the camera parameters as code
			const cameraCode = `// Camera position and lookAt parameters
camera.position.set(${position.x.toFixed(3)}, ${position.y.toFixed(3)}, ${position.z.toFixed(3)});
controls.target.set(${target.x.toFixed(3)}, ${target.y.toFixed(3)}, ${target.z.toFixed(3)});
controls.update();`;

			// Log to console
			console.log('=== Camera Parameters ===');
			console.log(cameraCode);
			console.log('========================');

			// Copy to clipboard if supported
			if (navigator.clipboard && window.isSecureContext) {
				navigator.clipboard.writeText(cameraCode).then(() => {
					console.log('Camera parameters copied to clipboard!');
				}).catch(err => {
					console.log('Failed to copy to clipboard:', err);
				});
			}

			// Show visual feedback
			showSaveFeedback();
		}

		function showSaveFeedback() {
			// Create a temporary visual feedback
			const feedback = document.createElement('div');
			feedback.textContent = 'Camera position saved! (Check console)';
			feedback.style.cssText = `
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background: rgba(0, 255, 0, 0.8);
				color: white;
				padding: 10px 20px;
				border-radius: 5px;
				font-family: Arial, sans-serif;
				font-size: 14px;
				z-index: 1000;
				pointer-events: none;
			`;
			document.body.appendChild(feedback);

			// Remove after 2 seconds
			setTimeout(() => {
				document.body.removeChild(feedback);
			}, 2000);
		}

		function animate() {

			stats.update();

			// Apply hover camera movement
			if (isHoveringScene || hoverCameraOffset.length() > 0.001) {
				camera.position.copy(originalCameraPosition).add(hoverCameraOffset);
				camera.lookAt(controls.target);
			}

			controls.update();

			TWEEN.update();

			postProcessing.render();

		}

		function random() {

			return (Math.random() - 0.5) * 2.0;

		}

		// Seeded random number generator for consistent tree generation
		function seededRandom(seed) {
			// Simple seeded random function
			const x = Math.sin(seed) * 10000;
			return (x - Math.floor(x)) * 2.0 - 1.0;
		}

		// Global seed for tree generation - change this value to get different but consistent trees
		const TREE_SEED = 45; // You can change this number to get different consistent trees

		// Tree customization parameters - modify these for different tree styles
		const TREE_PARAMS = {
			maxSteps: 4,        // Number of branching levels (higher = more complex)
			lengthMult: 0.85,   // How much shorter each branch gets (0.8-0.95) - reduced for more compact tree
			branchCount: 6,     // Number of branches per node (3-8) - increased for more balanced spread
			initialLength: 27,  // Starting branch length - reduced to prevent over-extension
			initialAngle: Math.PI * 0.5  // Starting angle (0 = right, PI/2 = up, PI = left)
		};

		let seedCounter = 0;

		function getNextSeed() {
			return TREE_SEED + seedCounter++;
		}

		function createTreeMesh() {

			const maxSteps = TREE_PARAMS.maxSteps;
			const lengthMult = TREE_PARAMS.lengthMult;

			const positions = [];
			const normals = [];
			const colors = [];
			const data = []; // will save seed, size and time

			let instanceCount = 0;

			const newPosition = new THREE.Vector3();
			const position = new THREE.Vector3();
			const normal = new THREE.Vector3();
			const color = new THREE.Color();

			function createTreePart(angle, x, y, z, length, count) {

				const branchSeed = getNextSeed();
				if (seededRandom(branchSeed) > (maxSteps / count) * 0.25) return;

				if (count < maxSteps) {

					const newLength = length * lengthMult;
					const newX = x + Math.cos(angle) * length;
					const newY = y + Math.sin(angle) * length;
					const countSq = Math.min(2.0, count * count); // Reduced from 3.2 to 2.0 for less Z spread
					const newZ = z + (seededRandom(getNextSeed()) * countSq - countSq / 4) * length * 0.5; // Added 0.5 multiplier to reduce Z elongation

					let size = 30 - (count * 8);
					if (size > 25) size = 25;
					if (size < 10) size = 10;

					size = size / 100;

					const subSteps = 60;

					// below loop generates the instanced data for a tree part

					for (let i = 0; i < subSteps; i++) {

						instanceCount++;

						const percent = i / subSteps;
						const extra = 1 / maxSteps;

						// position

						newPosition.set(x, y, z).lerp(new THREE.Vector3(newX, newY, newZ), percent);
						position.copy(newPosition);

						const posSeed = getNextSeed();
						position.x += seededRandom(posSeed) * size * 3; // Reduced from 3 to 2
						position.y += seededRandom(posSeed + 1) * size * 2; // Reduced from 3 to 2
						position.z += seededRandom(posSeed + 2) * size * 2; // Reduced from 3 to 1.5 for less Z spread

						positions.push(position.x, position.y, position.z);

						const scale = seededRandom(getNextSeed()) + 5;

						// normal

						normal.copy(position).sub(newPosition).normalize();
						normals.push(normal.x, normal.y, normal.z);

						// color

						const colorSeed = getNextSeed();
						color.setHSL((count / maxSteps) * 0.5 + seededRandom(colorSeed) * 0.05, 0.75, 0.6 + seededRandom(colorSeed + 1) * 0.1);
						colors.push(color.r, color.g, color.b);

						// to save vertex buffers, we store the size, time and seed in a single attribute

						const instanceSize = size * scale;
						const instanceTime = (count / maxSteps) + percent * extra;
						const instanceSeed = seededRandom(getNextSeed());

						data.push(instanceSize, instanceTime, instanceSeed);

					}

					// Create branches with seeded random variations
					for (let i = 0; i < TREE_PARAMS.branchCount; i++) {
						createTreePart(angle + seededRandom(getNextSeed()), newX, newY, newZ, newLength + seededRandom(getNextSeed()), count + 1);
					}

				}

			}

			const angle = TREE_PARAMS.initialAngle;

			// the tree is represented as a collection of instances boxes generated with below recursive function

			createTreePart(angle, 0, 0, 0, TREE_PARAMS.initialLength, 0);

			const geometry = new THREE.BoxGeometry();
			const material = new THREE.MeshStandardNodeMaterial();
			const mesh = new THREE.Mesh(geometry, material);
			mesh.scale.setScalar(0.06);
			mesh.count = instanceCount;
			mesh.frustumCulled = false;

			// instanced data

			const attributePosition = new THREE.InstancedBufferAttribute(new Float32Array(positions), 3);
			const attributeNormal = new THREE.InstancedBufferAttribute(new Float32Array(normals), 3);
			const attributeColor = new THREE.InstancedBufferAttribute(new Float32Array(colors), 3);
			const attributeData = new THREE.InstancedBufferAttribute(new Float32Array(data), 3);

			// TSL

			const instancePosition = instancedBufferAttribute(attributePosition);
			const instanceNormal = instancedBufferAttribute(attributeNormal);
			const instanceColor = instancedBufferAttribute(attributeColor);
			const instanceData = instancedBufferAttribute(attributeData);

			material.positionNode = Fn(() => {

				const instanceSize = instanceData.x;
				const instanceTime = instanceData.y;
				const instanceSeed = instanceData.z;

				// effectors (these are responsible for the blob-like scale effects)

				const dif1 = abs(instanceTime.sub(uniformEffector1)).toConst();
				let effect = dif1.lessThanEqual(0.15).select(sub(0.15, dif1).mul(sub(1.7, instanceTime).mul(10)), float(0));

				const dif2 = abs(instanceTime.sub(uniformEffector2)).toConst();
				effect = dif2.lessThanEqual(0.15).select(sub(0.15, dif2).mul(sub(1.7, instanceTime).mul(10)), effect);

				// Add smooth transition layer to prevent position reset
				// Create a gradual fade-out for smoother transitions
				const transitionFactor = float(1.0).sub(dif1.div(0.25)).clamp(0, 1).add(
					float(1.0).sub(dif2.div(0.25)).clamp(0, 1)
				).div(2).clamp(0, 1);
				
				// Apply smooth transition to the effect
				const smoothEffect = effect.mul(transitionFactor);

				// accumulate different vertex animations

				let animated = positionLocal.add(instancePosition).toVar();
				const direction = positionGeometry.normalize().toConst();

				animated = animated.add(direction.mul(smoothEffect.add(instanceSize)));
				animated = animated.sub(direction.mul(smoothEffect));
				animated = animated.add(instanceNormal.mul(smoothEffect.mul(1.5)));
				animated = animated.add(instanceNormal.mul(abs(sin(time.add(instanceSeed.mul(2))).mul(1.5))));

				return animated;

			})();

			const squareEdge = Fn(() => {

				const pos = uv().sub(vec2(0.5, 0.5));
				const squareDistance = max(abs(pos.x), abs(pos.y));
				return squareDistance.div(0.5).clamp(0.85, 1).sub(0.5).mul(2.0);

			})();

			material.colorNode = Fn(() => {
				return squareEdge.sub(instanceColor);
			})();

			material.emissiveNode = Fn(() => {
				const instanceTime = instanceData.y;

				// Improved emissive effect with proper vanishing
				const dif1 = abs(instanceTime.sub(uniformEffector1)).toConst();
				const effect1 = dif1.lessThanEqual(0.15).select(sub(0.15, dif1).mul(sub(1.7, instanceTime).mul(10)), float(0));

				const dif2 = abs(instanceTime.sub(uniformEffector2)).toConst();
				const effect2 = dif2.lessThanEqual(0.15).select(sub(0.15, dif2).mul(sub(1.7, instanceTime).mul(10)), effect1);

				// Ensure complete vanishing at the top by adding height-based fade
				const topFadeFactor = float(1.0).sub(instanceTime.mul(0.7)).clamp(0, 1);
				const finalEffect1 = effect1.mul(topFadeFactor);
				const finalEffect2 = effect2.mul(topFadeFactor);

				// Create smooth color cycling with interpolation
				const cycleTime = time.mul(0.3); // Slower speed for smoother transitions
				const cyclePhase = cycleTime.mod(3); // 3 phases: 0-1, 1-2, 2-3

				// Define 3 color schemes using final effects for proper vanishing
				const color1 = vec3(finalEffect1, finalEffect2, 0); // Red + Green = Yellow
				const color2 = vec3(0, finalEffect1, finalEffect2); // Green + Blue = Cyan  
				const color3 = vec3(finalEffect1, 0, finalEffect2); // Red + Blue = Purple

				// Smooth interpolation between colors
				let finalColor;

				if (cyclePhase.lessThan(1)) {
					// Interpolate between color1 and color2 (phase 0-1)
					const t = cyclePhase;
					finalColor = color1.mul(float(1).sub(t)).add(color2.mul(t));
				} else if (cyclePhase.lessThan(2)) {
					// Interpolate between color2 and color3 (phase 1-2)
					const t = cyclePhase.sub(1);
					finalColor = color2.mul(float(1).sub(t)).add(color3.mul(t));
				} else {
					// Interpolate between color3 and color1 (phase 2-3)
					const t = cyclePhase.sub(2);
					finalColor = color3.mul(float(1).sub(t)).add(color1.mul(t));
				}

				// Add outer glow effect around the tree
				// Create a soft glow that extends beyond the tree particles
				const glowIntensity = sin(time.mul(1.5)).mul(0.2).add(0.8); // Gentle pulsing glow
				const outerGlow = finalColor.mul(glowIntensity).mul(0.6); // Softer outer glow

				// Combine the main tree color with the outer glow
				const combinedGlow = finalColor.add(outerGlow);

				return pow2(combinedGlow).mul(instanceColor);
			})();

			return mesh;

		}

	</script>
</body>

</html>